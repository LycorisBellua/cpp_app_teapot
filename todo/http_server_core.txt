----- STATUS CODE --------------------------------------------------------------

The first digit of a status code indentifies the general category of response:
	- 1xx: Informational message only.
	- 2xx: Success of some kind.
	- 3xx: Redirects the client to another URL.
	- 4xx: Error on the client's part.
	- 5xx: Error on the server's part.

"400 Bad Request" is appropriate for a badly formatted request, and it takes 
precedence over a specific error, such as "405 Method Not Allowed".

----- SUPPORT HTTP/1.0 REQUESTS ------------------------------------------------

By default, connection is not persistent, so close it everytime unless the 
client sends "Connection: keep-alive".

The Host header line is optional. You can default to a main host in case of 
virtual hosting, as indeed we still need to know to which host forward the 
request.

Do not send chunked responses, and you must always specify Content-Length.

Stick to status codes that HTTP/1.0 recognizes:
	"200 OK"
	"201 Created"
	"202 Accepted"
	"204 No Content"
	"301 Moved Permanently"
	"302 Moved Temporarily"
	"304 Not Modified"
	"400 Bad Request"
	"401 Unauthorized"
	"403 Forbidden"
	"404 Not Found"
	"500 Internal Server Error"
	"501 Not Implemented"
	"502 Bad Gateway"
	"503 Service Unavailable"

Here are 4 other status codes that I use outside of HTTP/1.0:
	* "405 Method Not Allowed", to replace with "403 Forbidden".
	* "505 HTTP Version Not Supported" could have been replaced with "501 Not 
	Implemented", but if we don't recognize the version then we don't even know 
	that the client is HTTP/1.0. Therefore, use the status code which makes for 
	the version of your server.
	* Related to the "Expect 100 Continue" feature, which doesn't even exist in 
	HTTP/1.0, so it's fine:
		"100 Continue"
		"417 Expectation Failed"

----- WHITESPACES AND CRLF -----------------------------------------------------

The three fields of the request's start line should be separated by a single 
space, but someone might use another kind of whitespace and any number of them. 
It's legal, so accept any number of whitespaces between these fields.

It's legal to omit the space between a header line's name and value. Both 
"Content-Length: 4" and "Content-Length:4" are valid. Same thing for 
whitespaces around a comma or semi-colon: there could be none or several.

The colon between a header line's name and value is however mandatory.

Each header line (request or response) must end with CRLF (\r\n).

A header (request or response) must end with a blank line (CRLF on its own), 
even if there's no body. Otherwise, the other machine may wait indefinitely or 
close the connection as malformed.

Instead of CRLF, LF can also be allowed.

It's allowed to add CRLF or whatever whitespaces between a body and the next 
request, because the server will read according to Content-Length, and that 
outside of this length any whitespaces are interpreted as not being a request, 
so the server will know to wait for the start line. Also, note that the CRLF at 
the end of the body's single line is not needed. The server reads a certain 
amount of bytes, we don't care about CRLF within the body. It's only relevant 
to add them if the client wants them to be part of the body, otherwise they 
don't hurt because it's only whitespaces, so they'd be void space in between 
requests.

----- START LINE ---------------------------------------------------------------

If the request is not formatted properly, return "400 Bad Request".

Otherwise:

- For the method:
	* If the method is recognized, but not allowed for this specific resource, 
	return "405 Method Not Allowed". In the response, include the "Allow" 
	header line to list the allowed methods, such as `Allow: GET, POST`.
	* If the method is not recognized, return "501 Not Implemented". It works 
	for both methods that exist in the standard but you don't implement, and 
	those which don't exist at all. Also return the "Allow" line.

- For the URI:
	* If the resource is not found it's "404 Not Found".
	* If it's found but the method is not allowed, it's still "405 Method Not 
	Allowed" with the "Allow" header line listing what is allowed for this 
	specific URI.
	* And if the method is fine, then another possible error is "403 Forbidden" 
	if the client was denied access to this specific resource. It's different 
	from "401 Unauthorized", which can grant access if enough authentification 
	information is provided. With "403 Forbidden", nothing can be done, access 
	will forever be denied. I assume that 403 is appropriate in the context of 
	a lack of reading or writing permission (creating a new file, writing to 
	it, or reading from it).

- For the version:
	* If the version is not recognized, return "505 HTTP Version Not 
	Supported". In the response, you should also include which versions you 
	allow, such as `Allow: HTTP/1.0, HTTP/1.1`.

----- METHODS ------------------------------------------------------------------

The subject requires three methods: GET, POST and DELETE.
I'm also handling HEAD.

The HEAD method is when the client wants to send a GET request, but doesn't 
want to receive the response body. It's useful to check the characteristics of 
a resource without actually downloading it and thus saving bandwidth. Also, the 
config file doesn't need to explicitly allow HEAD, as it's the equivalent of 
GET. If GET is allowed, then HEAD is allowed.

The POST method is used to send data to the server to be processed in some way, 
like by a CGI script. It's different from the GET method in that:
	- the request has a body, and usually extra headers such as Content-Type 
	and Content-Length,
	- the request URI is not a resource to retrieve, it's usually a program to 
	handle the data being sent,
	- the response is normally program output and not a static file.

About CGI scripts, there are two ways to send data to them:
	- The POST method with a body:
	```
	POST /cgi-bin/script.cgi HTTP/1.1\r\n
	Host: example.com\r\n
	Content-Type: application/x-www-form-urlencoded\r\n
	Content-Length: 19\r\n
	\r\n
	name=John&age=30
	```
	- The GET method with data in the URI:
	```
	GET /cgi-bin/script.cgi?name=John&age=30 HTTP/1.1\r\n
	Host: example.com\r\n
	Connection: close\r\n
	\r\n
	```

A GET or DELETE request shouldn't have a body, your server is allowed to reject 
the request.

A POST request should have a body. If there's none, then the request should 
specify "Content-Length: 0" or a Transfer-Encoding to express the same thing. 
And if the header line is not present, then your server should assume that 
there's no body, and that the next part of the data is a new request. In 
practice, many servers reject the request or close the connection, because the 
boundary is ambiguous if pipelining is expected.

----- HOST ---------------------------------------------------------------------

The "Host" header line is required in HTTP/1.1. Parse it to know who the 
request is intended for. It indicates not only the domain but the port. For 
example, `www.host1.com:80`. Of course, if there's no port, interpret it as 80.

Accept abolute URLs. Both of these initial request lines are valid:
	- "GET /path/file.html HTTP/1.1"
	- "GET http://www.somehost.com/path/file.html HTTP/1.1"
The "Host" header line is still required though.

----- CHUNKED TRANSFER ENCODING ------------------------------------------------

Chunked transfer-encoding is indicated by the "Transfer-Encoding: chunked" 
header, which can be used by requests and responses alike. Although the server 
is not required to send chunked responses, it must be able to receive chunked 
requests. This feature is used when the sender doesn't know the size of the 
body, and would rather send it in chunks. The size of the next chunk is 
indicated, of course, and then the end of the body is marked. The subject 
doesn't require the response to use this encoding, but the request might use it 
so it's important to know how to parse and "unchunk" such a request, so that 
the parsed request body ends up as a block ended with EOF and with the full 
byte size calculated for good measure.

Example of classic request:
	```
	POST /upload HTTP/1.1\r\n
	Host: example.com\r\n
	Content-Type: text/plain\r\n
	Content-Length: 15\r\n
	\r\n
	0123456789abcde
	```

Example of chunked request:
	```
	POST /upload HTTP/1.1\r\n
	Host: example.com\r\n
	Content-Type: text/plain\r\n
	Transfer-Encoding: chunked\r\n
	\r\n
	A\r\n
	0123456789\r\n
	5\r\n
	abcde\r\n
	0;note="final chunk"\r\n
	X-Checksum: sha256:abcd1234\r\n
	X-Meta: part=7\r\n
	\r\n
	```

Each chunk is prefaced with the byte size in hex format. This value can be 
followed by a semicolon, and extra parameters. Ignore everything in between the 
byte size value and CRLF.

A final size line of 0 is given at the end to indicate that the chunks have 
all been sent.

In between this final size line and the final CRLF line, trailer lines can be 
found. Ignore them.

From subject: "Remember that for chunked requests your server needs to un-chunk 
them, as the CGI will expect EOF as the end of the body."

----- CONNECTION PERSISTENCE ---------------------------------------------------

In HTTP/1.1, connection is persistent. It means that the same connection can be 
used to exchange requests and responses back and forth. However, if the client 
has the "Connection: close" header line, it means that it closes the connection 
after the response has been received. Similarly, if the server sends a response 
with this header line, it closes connection right after.

The client sending multiple requests over the same connection without waiting 
for the corresponding responses is called "pipelining". The server is expected 
to send back the responses in the same order the requests were received.
	- Example of pipelining:
	```
	POST /submit HTTP/1.1\r\n
	Host: example.com\r\n
	Content-Length: 0\r\n
	\r\n
	GET /next HTTP/1.1\r\n
	Host: example.com\r\n
	\r\n
	```
	- Another example of pipelining:
	```
	POST /submit HTTP/1.1\r\n
	Host: example.com\r\n
	Content-Type: application/x-www-form-urlencoded\r\n
	Content-Length: 13\r\n
	\r\n
	name=alice123\r\n
	GET /next HTTP/1.1\r\n
	Host: example.com\r\n
	\r\n
	```

If the client wants to close the connection, it either must send 
"Connection: close" within the header of its last request, or close the TCP 
connection abruptly.

"Connection: keep-alive" is optional, as in HTTP/1.1 persistent connection is 
the default anyway. Ignore any other connection than "close", honestly.

Your server must close the connection after a fatal error. A fatal error is a 
malformed request, whereas a recoverable error is when the request was readable 
but the server cannot fulfill it. Use the correct status code, and if it's not 
within the scope of the project to be very precise, then at least use "400 Bad 
Request".

Whether it's to echo the request's desire to close the connection, or in case 
of a fatal error, of course the response must contain "Connection: close".

If the connection is idle, the server should close it after some timeout period 
(it can be anything, 10 seconds is fine).

----- EXPECT 100 CONTINUE ------------------------------------------------------

The client can send a header with the "Expect: 100-continue" line and without a 
body. It's asking the server whether the header is valid. If it's not, the 
server sends an error, and the client knows not to send the body for nothing. 
If the header was valid, the server sends "HTTP/1.1 100 Continue\r\n\r\n", and 
the client knows to send the body.

If the client sends the body right away, the server doesn't have to bother with 
responding with 100. It becomes the same as a typical request, but in case of 
an error the server has to read and discard the body fully, it cannot stop at 
the header, or the socket will be a mess.

Note that the "417 Expectation Failed" error is only if the server rejects the 
"Expect" header line itself, for example because the feature is not 
implemented, or the expect value is not "100-continue", as it's the only one 
that exists. Of course, if the header had another issue, you send "400 Bad 
Request", but if the only issue is the Expect value, it's 417.

----- DATE ---------------------------------------------------------------------

Except for the "100 Continue" response, all responses must include the date, 
and it must use Greenwich Mean Time: "Date: Fri, 31 Dec 1999 23:59:59 GMT". The 
purpose of this is to allow the client to use caching, which doesn't work 
without timestamps. The server can ignore the "Date" request header line.

----- TODO AFTER PARSING THE REQUEST -------------------------------------------

[Map request to a route]

- Call your mate's routing API
- Determine:
	* which file to serve
	* whether to run CGI
	* allowed methods
	* upload directory
	* redirects

[Handle cookies and session management]

- Read `Cookie` headers from request
- Look up session in memory or using session ID
- Create new session if none exists or expired
- Attach session data to request context for route handlers

[Build the HTTP response]

- Status line
- Headers
- Content-Length or Transfer-Encoding
- Body (static file, upload result, CGI output, error page, etc)

[Set cookies for session management]

- If session was created or modified -> send `Set-Cookie` header
- Include any other cookies the route requires

[Ports]

- One port per server, and possibly different servers. It's not asked in the 
subject, but why not.
