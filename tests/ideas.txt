These let you test line-by-line HTTP behavior.

Simple GET:
```
curl -v http://localhost:PORT/
```

HTTP/1.1 forced:
```
curl -v --http1.1 http://localhost:PORT/
```

Chunked POST:
```
curl -v -X POST -H "Transfer-Encoding: chunked" --data-binary @file \
http://localhost:PORT/upload
```

DELETE method:
```
curl -v -X DELETE http://localhost:PORT/file
```

Test keep-alive:
```
curl -v http://localhost:PORT/ -H "Connection: keep-alive"
```

Test absolute form URI:
```
printf "GET http://www.example.com/hello/world HTTP/1.1\r\nHost: \
localhost\r\n\r\n" | nc localhost 8080
```

Test malformed headers:
```
printf "GET / HTTP/1.1\r\nHost: localhost\r\nX: \r\n\r\n" | nc localhost PORT
```

You can use netcat or telnet to send invalid, partial, and weird HTTP requests 
that curl will never generate. These reveal parser and state-machine bugs.

Example: missing Host header (must return 400)
```
GET / HTTP/1.1
Connection: close
```

Example: pipeline multiple requests (persistent connection)
```
GET /page1 HTTP/1.1
Host: localhost

GET /page2 HTTP/1.1
Host: localhost
```

Example: send request in fragments (your parser must handle)
```
GET /HT
TP/1.1
Host: loca
lhost
```
