+------------------------------------------------------------------------------+
|                   Browser tests (for real-world behavior)                    |
+------------------------------------------------------------------------------+

Modern browsers will test:

- Correct parsing
- Persistent connections
- Content-Length correctness
- Error codes
- MIME types
- Static file serving
- Directory listing (if enabled)
- Default index file
- Redirections

You can simply open:

```
http://localhost:PORT/
```

Use Chrome/Firefox devtools (Network tab):
- Check response headers you send
- Check connection reuse (Keep-Alive)
- Test cached vs noncached requests
- Check that you never hang

+------------------------------------------------------------------------------+
|                Command-line tests (the real RFC verification)                |
+------------------------------------------------------------------------------+

These let you test line-by-line HTTP behavior.

Simple GET:
```
curl -v http://localhost:PORT/
```

HTTP/1.1 forced:
```
curl -v --http1.1 http://localhost:PORT/
```

Chunked POST:
```
curl -v -X POST -H "Transfer-Encoding: chunked" --data-binary @file \
http://localhost:PORT/upload
```

DELETE method:
```
curl -v -X DELETE http://localhost:PORT/file
```

Test keep-alive:
```
curl -v http://localhost:PORT/ -H "Connection: keep-alive"
```

Test absolute form URI:
```
printf "GET http://www.example.com/hello/world HTTP/1.1\r\nHost: \
localhost\r\n\r\n" | nc localhost 8080
```

Test malformed headers:
```
printf "GET / HTTP/1.1\r\nHost: localhost\r\nX: \r\n\r\n" | nc localhost PORT
```

You can use netcat or telnet to send invalid, partial, and weird HTTP requests 
that curl will never generate. These reveal parser and state-machine bugs.

Example: missing Host header (must return 400)
```
GET / HTTP/1.1
Connection: close
```

Example: pipeline multiple requests (persistent connection)
```
GET /page1 HTTP/1.1
Host: localhost

GET /page2 HTTP/1.1
Host: localhost
```

Example: send request in fragments (your parser must handle)
```
GET /HT
TP/1.1
Host: loca
lhost
```

+------------------------------------------------------------------------------+
|                         Compare behavior with NGINX                          |
+------------------------------------------------------------------------------+

Steps:
- Create an nginx.conf with a similar route structure.
- Start NGINX on port 8080.
- Start your server on 8081.
- Test:
```
curl -v http://localhost:8080/something
curl -v http://localhost:8081/something
```

Side-by-side differences reveal:
- Missing headers
- Wrong status codes
- Wrong connection behavior
- Wrong chunking
- Wrong CGI environment variables

+------------------------------------------------------------------------------+
|                       A Complete Test Plan (checklist)                       |
+------------------------------------------------------------------------------+

Parser / Requests
- Multiple headers with same name
- Header folding (you may choose not to support it — deprecated)
- Missing Host → 400
- Missing final `\r\n\r\n` → timeout
- Chunked transfer
- Oversized body (beyond max allowed)
- Unsupported method → 405
- Unsupported HTTP version → 505

GET Method
- Existing file
- Directory with index
- Directory listing
- Nonexistent path → 404
- Permission denied → 403

POST Method
- With Content-Length
- With chunked Transfer-Encoding
- Large uploads
- Writing to configured upload directory

DELETE Method
- Delete allowed
- Delete not allowed → 405
- Delete nonexistent → 404

Connections
- Keep-Alive (persistent)
- Connection: close
- Pipeline multiple requests

Responses
- Correct status codes
- Correct Content-Length
- Correct headers order
- Correct CRLF endings
- Default error pages

CGI
- Pass correct environment variables
- Correct working directory
- Handle both Content-Length and chunked input
- Handle CGI without Content-Length (EOF)
- CGI returning headers and body correctly
- CGI crash handling
Use a small Python CGI for testing:
```
#!/usr/bin/env python3
print("Content-Type: text/plain\r\n\r\n")
print("Hello CGI")
```
